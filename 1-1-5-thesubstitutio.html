<!DOCTYPE html
  PUBLIC "html">
<meta xmlns:doc="http://jaredkrinke.github.io/doc" name="viewport" content="width=device-width, initial-scale=1"><html xmlns:doc="http://jaredkrinke.github.io/doc" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>(learn 'scheme) - The Substitution Model for Procedure Application</title><script src="https://code.jquery.com/jquery-2.1.1.min.js"></script><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css"><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/codemirror.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/codemirror.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/mode/scheme/scheme.min.js"></script><script src="jsLisp.js"></script><script src="editor.js"></script><link rel="stylesheet" href="editor.css"></head><body><div class="container"><nav class="navbar navbar-default"><div class="navbar-header"><button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#top-bar"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="index.html">(learn 'scheme)</a></div><div class="collapse navbar-collapse" id="top-bar"><ul class="nav navbar-nav"><li><a href="1-1-4-compoundproced.html">&laquo; Previous</a></li><li class=""><a href="toc.html">Contents</a></li><li><a href="1-1-6-conditionalexp.html">Next &raquo;</a></li></ul><form class="navbar-form navbar-right"><button id="launchEditor" type="button" class="btn btn-default">Launch Editor</button></form></div></nav><h1>The Substitution Model for Procedure Application</h1>
<p>To evaluate a combination whose operator names a compound procedure, the interpreter follows much the same process as for combinations whose operators name primitive procedures, which we described in section 1.1.3.  That is, the interpreter evaluates the elements of the combination and applies the procedure (which is the value of the operator of the combination) to the arguments (which are the values of the operands of the combination).</p>
<p>We can assume that the mechanism for applying primitive procedures to arguments is built into the interpreter.  For compound procedures, the application process is as follows:</p>
<ul>
<li>To apply a compound procedure to arguments, evaluate the body of the procedure with each formal parameter replaced by the corresponding argument. </li>
</ul>
<p>To illustrate this process, let's evaluate the combination</p>
<pre class="code-invalid">(f 5)</pre>
<p>where <code>f</code> is the procedure defined in section 1.1.4.  We begin by retrieving the body of <code>f</code>:</p>
<pre class="code-invalid">(sum-of-squares (+ a 1) (* a 2))</pre>
<p>Then we replace the formal parameter <code>a</code> by the argument 5:</p>
<pre class="code-invalid">(sum-of-squares (+ 5 1) (* 5 2))</pre>
<p>Thus the problem reduces to the evaluation of a combination with two operands and an operator <code>sum-of-squares</code>.  Evaluating this combination involves three subproblems.  We must evaluate the operator to get the procedure to be applied, and we must evaluate the operands to get the arguments.  Now <code>(+ 5 1)</code> produces 6 and <code>(* 5 2)</code> produces 10, so we must apply the <code>sum-of-squares</code> procedure to 6 and 10.  These values are substituted for the formal parameters <code>x</code> and <code>y</code> in the body of <code>sum-of-squares</code>, reducing the expression to</p>
<pre class="code-invalid">(+ (square 6) (square 10))</pre>
<p>If we use the definition of <code>square</code>, this reduces to</p>
<pre class="code-invalid">(+ (* 6 6) (* 10 10))</pre>
<p>which reduces by multiplication to</p>
<pre class="code-invalid">(+ 36 100)</pre>
<p>and finally to</p>
<pre class="code-invalid">136</pre>
<p>The process we have just described is called the <strong>substitution model</strong> for procedure application.  It can be taken as a model that determines the "meaning" of procedure application, insofar as the procedures in this chapter are concerned.  However, there are two points that should be stressed:</p>
<ul>
<li>The purpose of the substitution is to help us think about procedure application, not to provide a description of how the interpreter really works.  Typical interpreters do not evaluate procedure applications by manipulating the text of a procedure to substitute values for the formal parameters.  In practice, the "substitution" is accomplished by using a local environment for the formal parameters.  We will discuss this more fully in chapters 3 and 4 when we examine the implementation of an interpreter in detail.  </li>
<li>Over the course of this book, we will present a sequence of increasingly elaborate models of how interpreters work, culminating with a complete implementation of an interpreter and compiler in chapter 5.  The substitution model is only the first of these models -- a way to get started thinking formally about the evaluation process.  In general, when modeling phenomena in science and engineering, we begin with simplified, incomplete models.  As we examine things in greater detail, these simple models become inadequate and must be replaced by more refined models.  The substitution model is no exception.  In particular, when we address in chapter 3 the use of procedures with "mutable data," we will see that the substitution model breaks down and must be replaced by a more complicated model of procedure application.<sup><a href="#footnote_15">15</a></sup> </li>
</ul>
<h2>Applicative order versus normal order</h2><p>According to the description of evaluation given in section 1.1.3, the interpreter first evaluates the operator and operands and then applies the resulting procedure to the resulting arguments.  This is not the only way to perform evaluation.  An alternative evaluation model would not evaluate the operands until their values were needed.  Instead it would first substitute operand expressions for parameters until it obtained an expression involving only primitive operators, and would then perform the evaluation.  If we used this method, the evaluation of</p>
<pre class="code-invalid">(f 5)</pre>
<p>would proceed according to the sequence of expansions</p>
<pre class="code-invalid">(sum-of-squares (+ 5 1) (* 5 2))

(+    (square (+ 5 1))      (square (* 5 2))  )

(+    (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))</pre>
<p>followed by the reductions</p>
<pre class="code-invalid">(+         (* 6 6)             (* 10 10))

(+           36                   100)

                    136</pre>
<p>This gives the same answer as our previous evaluation model, but the process is different.  In particular, the evaluations of <code>(+ 5 1)</code> and <code>(* 5 2)</code> are each performed twice here, corresponding to the reduction of the expression</p>
<pre class="code-invalid">(* x x)</pre>
<p>with <code>x</code> replaced respectively by <code>(+ 5 1)</code> and <code>(* 5 2)</code>.</p>
<p>This alternative "fully expand and then reduce" evaluation method is known as <strong>normal-order evaluation</strong>, in contrast to the "evaluate the arguments and then apply" method that the interpreter actually uses, which is called <strong>applicative-order evaluation</strong>.  It can be shown that, for procedure applications that can be modeled using substitution (including all the procedures in the first two chapters of this book) and that yield legitimate values, normal-order and applicative-order evaluation produce the same value.  (See exercise 1.5 for an instance of an "illegitimate" value where normal-order and applicative-order evaluation do not give the same result.)</p>
<p>Lisp uses applicative-order evaluation, partly because of the additional efficiency obtained from avoiding multiple evaluations of expressions such as those illustrated with <code>(+ 5 1)</code> and <code>(* 5 2)</code> above and, more significantly, because normal-order evaluation becomes much more complicated to deal with when we leave the realm of procedures that can be modeled by substitution.  On the other hand, normal-order evaluation can be an extremely valuable tool, and we will investigate some of its implications in chapters 3 and 4.<sup><a href="#footnote_16">16</a></sup></p>

<hr><small><p><sup><a name="footnote_15"></a>15</sup>Despite the simplicity of the substitution idea, it turns out to be surprisingly complicated to give a rigorous mathematical definition of the substitution process.  The problem arises from the possibility of confusion between the names used for the formal parameters of a procedure and the (possibly identical) names used in the expressions to which the procedure may be applied.  Indeed, there is a long history of erroneous definitions of <strong>substitution</strong> in the literature of logic and programming semantics.  See Stoy 1977 for a careful discussion of substitution.   </p>
</small><small><p><sup><a name="footnote_16"></a>16</sup>In chapter 3 we will introduce <strong>stream processing</strong>, which is a way of handling apparently "infinite" data structures by incorporating a limited form of normal-order evaluation.  In section 4.2 we will modify the Scheme interpreter to produce a normal-order variant of Scheme.   </p>
</small><nav><ul class="pager"><li><a href="1-1-4-compoundproced.html"><span>&laquo; Previous</span></a></li><li><a href="toc.html">Contents</a></li><li><a href="1-1-6-conditionalexp.html"><span>Next &raquo;</span></a></li></ul></nav><button id="tryItButton" class="hidden btn btn-info btn-xs pull-right">Try it</button></div><div id="editorModal" class="modal fade" tabindex="-1" role="dialog"><div class="modal-dialog modal-lg"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><h4 class="modal-title">Scheme Interpreter</h4></div><div class="modal-body"><label for="editorInput">Input</label><textarea id="editorInput" class="form-control"></textarea></div><div class="modal-body"><label for="editorOutput">Output</label><textarea id="editorOutput" class="form-control"></textarea></div><div class="modal-footer"><button id="editorExecute" type="button" class="btn btn-primary">Evaluate</button><button id="editorDismiss" type="button" class="btn btn-default" data-dismiss="modal">Close</button></div></div></div></div></body></html>