<!DOCTYPE html
  PUBLIC "html">
<meta xmlns:doc="http://jaredkrinke.github.io/doc" name="viewport" content="width=device-width, initial-scale=1"><html xmlns:doc="http://jaredkrinke.github.io/doc" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>(learn 'scheme) - Naming and the Environment</title><script src="https://code.jquery.com/jquery-2.1.1.min.js"></script><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css"><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/codemirror.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/codemirror.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/mode/scheme/scheme.min.js"></script><script src="jsLisp.js"></script><script src="editor.js"></script><link rel="stylesheet" href="editor.css"></head><body><div class="container"><nav class="navbar navbar-default"><div class="navbar-header"><button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#top-bar"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="index.html">(learn 'scheme)</a></div><div class="collapse navbar-collapse" id="top-bar"><ul class="nav navbar-nav"><li><a href="1-1-1-expressions.html">&laquo; Previous</a></li><li class=""><a href="toc.html">Contents</a></li><li><a href="1-1-3-evaluatingcomb.html">Next &raquo;</a></li></ul><form class="navbar-form navbar-right"><button id="launchEditor" type="button" class="btn btn-default">Launch Editor</button></form></div></nav><h1>Naming and the Environment</h1>
<p>A critical aspect of a programming language is the means it provides for using names to refer to computational objects.  We say that the name identifies a <strong>variable</strong> whose <strong>value</strong> is the object.</p>
<p>In the Scheme dialect of Lisp, we name things with <code>define</code>.  Typing</p>
<pre>(define size 2)</pre>
<p>causes the interpreter to associate the value 2 with the name <code>size</code>.<sup><a href="#footnote_8">8</a></sup> Once the name <code>size</code> has been associated with the number 2, we can  refer to the value 2 by name:</p>
<div class="hidden hidden-code">(define size 2)</div><pre>size</pre>
<blockquote>2</blockquote>
<div class="hidden hidden-code">(define size 2)</div><pre>(* 5 size)</pre>
<blockquote>10</blockquote>
<p>Here are further examples of the use of <code>define</code>:</p>
<pre>(define pi 3.14159)
(define radius 10)
(* pi (* radius radius))</pre>
<blockquote>314.159</blockquote>
<div class="hidden hidden-code">(define pi 3.14159)
(define radius 10)</div><pre>(define circumference (* 2 pi radius))
circumference</pre>
<blockquote>62.8318</blockquote>
<p><code>Define</code> is our language's simplest means of abstraction, for it allows us to use simple names to refer to the results of compound operations, such as the <code>circumference</code> computed above. In general, computational objects may have very complex structures, and it would be extremely inconvenient to have to remember and repeat their details each time we want to use them.  Indeed, complex programs are constructed by building, step by step, computational objects of increasing complexity. The interpreter makes this step-by-step program construction particularly convenient because name-object associations can be created incrementally in successive interactions.  This feature encourages the incremental development and testing of programs and is largely responsible for the fact that a Lisp program usually consists of a large number of relatively simple procedures.</p>
<p>It should be clear that the possibility of associating values with symbols and later retrieving them means that the interpreter must maintain some sort of memory that keeps track of the name-object pairs.  This memory is called the <strong>environment</strong> (more precisely the <strong>global environment</strong>, since we will see later that a computation may involve a number of different environments).<sup><a href="#footnote_9">9</a></sup></p>
<hr><small><p><sup><a name="footnote_8"></a>8</sup>In this book, we do not show the interpreter's response to evaluating definitions, since this is highly implementation-dependent.   </p>
</small><small><p><sup><a name="footnote_9"></a>9</sup>Chapter 3 will show that this notion of environment is crucial, both for understanding how the interpreter works and for implementing interpreters.   </p>
</small><nav><ul class="pager"><li><a href="1-1-1-expressions.html"><span>&laquo; Previous</span></a></li><li><a href="toc.html">Contents</a></li><li><a href="1-1-3-evaluatingcomb.html"><span>Next &raquo;</span></a></li></ul></nav><button id="tryItButton" class="hidden btn btn-info btn-xs pull-right">Try it</button></div><div id="editorModal" class="modal fade" tabindex="-1" role="dialog"><div class="modal-dialog modal-lg"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><h4 class="modal-title">Scheme Interpreter</h4></div><div class="modal-body"><label for="editorInput">Input</label><textarea id="editorInput" class="form-control"></textarea></div><div class="modal-body"><label for="editorOutput">Output</label><textarea id="editorOutput" class="form-control"></textarea></div><div class="modal-footer"><button id="editorExecute" type="button" class="btn btn-primary">Evaluate</button><button id="editorDismiss" type="button" class="btn btn-default" data-dismiss="modal">Close</button></div></div></div></div></body></html>