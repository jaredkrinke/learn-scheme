<!DOCTYPE html
  PUBLIC "html">
<meta xmlns:doc="http://jaredkrinke.github.io/doc" name="viewport" content="width=device-width, initial-scale=1"><html xmlns:doc="http://jaredkrinke.github.io/doc" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>(learn 'scheme) - Greatest Common Divisors</title><script src="https://code.jquery.com/jquery-2.1.1.min.js"></script><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css"><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/codemirror.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/codemirror.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/mode/scheme/scheme.min.js"></script><script src="jsLisp.js"></script><script src="editor.js"></script><link rel="stylesheet" href="editor.css"></head><body><div class="container"><nav class="navbar navbar-default"><div class="navbar-header"><button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#top-bar"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="index.html">(learn 'scheme)</a></div><div class="collapse navbar-collapse" id="top-bar"><ul class="nav navbar-nav"><li><a href="1-2-4-exponentiation.html">&laquo; Previous</a></li><li class=""><a href="toc.html">Contents</a></li><li><a href="1-2-6-exampletesting.html">Next &raquo;</a></li></ul><form class="navbar-form navbar-right"><button id="launchEditor" type="button" class="btn btn-default">Launch Editor</button></form></div></nav><h1>Greatest Common Divisors</h1>
<p>The greatest common divisor (GCD) of two integers <strong>a</strong> and <strong>b</strong> is defined to be the largest integer that divides both <strong>a</strong> and <strong>b</strong> with no remainder.  For example, the GCD of 16 and 28 is 4.  In chapter 2, when we investigate how to implement rational-number arithmetic, we will need to be able to compute GCDs in order to reduce rational numbers to lowest terms.  (To reduce a rational number to lowest terms, we must divide both the numerator and the denominator by their GCD.  For example, 16/28 reduces to 4/7.)  One way to find the GCD of two integers is to factor them and search for common factors, but there is a famous algorithm that is much more efficient.</p>
<p>The idea of the algorithm is based on the observation that, if <strong>r</strong> is the remainder when <strong>a</strong> is divided by <strong>b</strong>, then the common divisors of <strong>a</strong> and <strong>b</strong> are precisely the same as the common divisors of <strong>b</strong> and <strong>r</strong>.  Thus, we can use the equation </p>

<div class=".pull-left"><img src="ch1-Z-G-24.gif"></div>
<p>to successively reduce the problem of computing a GCD to the problem of computing the GCD of smaller and smaller pairs of integers.  For example, </p>

<div class=".pull-left"><img src="ch1-Z-G-25.gif"></div>
<p>reduces GCD(206,40) to GCD(2,0), which is 2.  It is possible to show that starting with any two positive integers and performing repeated reductions will always eventually produce a pair where the second number is 0.  Then the GCD is the other number in the pair.  This method for computing the GCD is known as <strong>Euclid's Algorithm</strong>.<sup><a href="#footnote_41">41</a></sup></p>
<p>It is easy to express Euclid's Algorithm as a procedure: </p>
<pre>(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))</pre>
<p>This generates an iterative process, whose number of steps grows as the logarithm of the numbers involved.</p>
<p>The fact that the number of steps required by Euclid's Algorithm has logarithmic growth bears an interesting relation to the Fibonacci numbers:</p>
<p>compute the GCD of some pair, then the smaller number in the pair must be greater than or equal to the <strong>k</strong>th Fibonacci number.<sup><a href="#footnote_42">42</a></sup></p>
<p>We can use this theorem to get an order-of-growth estimate for Euclid's Algorithm.  Let <strong>n</strong> be the smaller of the two inputs to the procedure.  If the process takes <strong>k</strong> steps, then we must have  <strong>n</strong><u>&gt;</u>  <strong>F</strong><strong>i</strong><strong>b</strong> (<strong>k</strong>) <img src="book-Z-G-D-20.gif" border="0"> <img src="book-Z-G-D-11.gif" border="0"><sup><strong>k</strong></sup>/<img src="book-Z-G-D-13.gif" border="0">5.  Therefore the number of steps <strong>k</strong> grows as the logarithm (to the base <img src="book-Z-G-D-11.gif" border="0">) of <strong>n</strong>.  Hence, the order of growth is <img src="book-Z-G-D-3.gif" border="0">(<code>log</code> <strong>n</strong>).</p>

<u>Exercise 1.20</u><p>The process that a procedure generates is of course dependent on the rules used by the interpreter.  As an example, consider the iterative <code>gcd</code> procedure given above. Suppose we were to interpret this procedure using normal-order evaluation, as discussed in section 1.1.5. (The normal-order-evaluation rule for <code>if</code> is described in exercise 1.5.)  Using the substitution method (for normal order), illustrate the process generated in evaluating <code>(gcd 206 40)</code> and indicate the <code>remainder</code> operations that are actually performed. How many <code>remainder</code> operations are actually performed in the normal-order evaluation of <code>(gcd 206 40)</code>? In the applicative-order evaluation? </p>

<hr><small><p><sup><a name="footnote_41"></a>41</sup>Euclid's Algorithm is so called because it appears in Euclid's <strong>Elements</strong> (Book 7, ca. 300 B.C.).  According to Knuth (1973), it can be considered the oldest known nontrivial algorithm.  The ancient Egyptian method of multiplication (exercise 1.18) is surely older, but, as Knuth explains, Euclid's algorithm is the oldest known to have been presented as a general algorithm, rather than as a set of illustrative examples.   </p>
</small><small><p><sup><a name="footnote_42"></a>42</sup>This theorem was proved in 1845 by Gabriel Lam√©, a French mathematician and engineer known chiefly for his contributions to mathematical physics.  To prove the theorem, we consider pairs (<strong>a</strong><sub><strong>k</strong></sub> ,<strong>b</strong><sub><strong>k</strong></sub>), where <strong>a</strong><sub><strong>k</strong></sub><u>&gt;</u> <strong>b</strong><sub><strong>k</strong></sub>, for which Euclid's Algorithm terminates in <strong>k</strong> steps.  The proof is based on the claim that, if (<strong>a</strong><sub><strong>k</strong>+1</sub>, <strong>b</strong><sub><strong>k</strong>+1</sub>)  <img src="book-Z-G-D-15.gif" border="0">  (<strong>a</strong><sub><strong>k</strong></sub>, <strong>b</strong><sub><strong>k</strong></sub>)  <img src="book-Z-G-D-15.gif" border="0">  (<strong>a</strong><sub><strong>k</strong>-1</sub>, <strong>b</strong><sub><strong>k</strong>-1</sub>) are three successive pairs in the reduction process, then we must have <strong>b</strong><sub><strong>k</strong>+1</sub><u>&gt;</u> <strong>b</strong><sub><strong>k</strong></sub>  +  <strong>b</strong><sub><strong>k</strong>-1</sub>. To verify the claim, consider that a reduction step is defined by applying the transformation <strong>a</strong><sub><strong>k</strong>-1</sub>  =  <strong>b</strong><sub><strong>k</strong></sub>, <strong>b</strong><sub><strong>k</strong>-1</sub>  =   remainder of  <strong>a</strong><sub><strong>k</strong></sub> divided by <strong>b</strong><sub><strong>k</strong></sub>.   The second equation means that <strong>a</strong><sub><strong>k</strong></sub>  =  <strong>q</strong><strong>b</strong><sub><strong>k</strong></sub>  +  <strong>b</strong><sub><strong>k</strong>-1</sub> for some positive integer <strong>q</strong>.  And since <strong>q</strong> must be at least 1 we have <strong>a</strong><sub><strong>k</strong></sub>  =  <strong>q</strong><strong>b</strong><sub><strong>k</strong></sub>  +  <strong>b</strong><sub><strong>k</strong>-1</sub> <u>&gt;</u> <strong>b</strong><sub><strong>k</strong></sub>  +  <strong>b</strong><sub><strong>k</strong>-1</sub>.  But in the previous reduction step we have <strong>b</strong><sub><strong>k</strong>+1</sub> =  <strong>a</strong><sub><strong>k</strong></sub>.  Therefore, <strong>b</strong><sub><strong>k</strong>+1</sub>  =  <strong>a</strong><sub><strong>k</strong></sub><u>&gt;</u> <strong>b</strong><sub><strong>k</strong></sub>  +  <strong>b</strong><sub><strong>k</strong>-1</sub>.  This verifies the claim.  Now we can prove the theorem by induction on <strong>k</strong>, the number of steps that the algorithm requires to terminate.  The result is true for <strong>k</strong> = 1, since this merely requires that <strong>b</strong> be at least as large as  <strong>F</strong><strong>i</strong><strong>b</strong>(1) = 1.  Now, assume that the result is true for all integers less than or equal to <strong>k</strong> and establish the result for <strong>k</strong> + 1.  Let (<strong>a</strong><sub><strong>k</strong>+1</sub>, <strong>b</strong><sub><strong>k</strong>+1</sub>) <img src="book-Z-G-D-15.gif" border="0"> (<strong>a</strong><sub><strong>k</strong></sub>, <strong>b</strong><sub><strong>k</strong></sub>)  <img src="book-Z-G-D-15.gif" border="0"> (<strong>a</strong><sub><strong>k</strong>-1</sub>, <strong>b</strong><sub><strong>k</strong>-1</sub>) be successive pairs in the reduction process.  By our induction hypotheses, we have <strong>b</strong><sub><strong>k</strong>-1</sub><u>&gt;</u>  <strong>F</strong><strong>i</strong><strong>b</strong>(<strong>k</strong> - 1) and <strong>b</strong><sub><strong>k</strong></sub><u>&gt;</u>  <strong>F</strong><strong>i</strong><strong>b</strong>(<strong>k</strong>).  Thus, applying the claim we just proved together with the definition of the Fibonacci numbers gives <strong>b</strong><sub><strong>k</strong>+1</sub> <u>&gt;</u> <strong>b</strong><sub><strong>k</strong></sub>  +  <strong>b</strong><sub><strong>k</strong>-1</sub><u>&gt;</u>  <strong>F</strong><strong>i</strong><strong>b</strong>(<strong>k</strong>)  +   <strong>F</strong><strong>i</strong><strong>b</strong>(<strong>k</strong> - 1)  =  <strong>F</strong><strong>i</strong><strong>b</strong>(<strong>k</strong> + 1), which completes the proof of Lam√©'s Theorem.   </p>
</small><nav><ul class="pager"><li><a href="1-2-4-exponentiation.html"><span>&laquo; Previous</span></a></li><li><a href="toc.html">Contents</a></li><li><a href="1-2-6-exampletesting.html"><span>Next &raquo;</span></a></li></ul></nav><button id="tryItButton" class="hidden btn btn-info btn-xs pull-right">Try it</button></div><div id="editorModal" class="modal fade" tabindex="-1" role="dialog"><div class="modal-dialog modal-lg"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><h4 class="modal-title">Scheme Interpreter</h4></div><div class="modal-body"><label for="editorInput">Input</label><textarea id="editorInput" class="form-control"></textarea></div><div class="modal-body"><label for="editorOutput">Output</label><textarea id="editorOutput" class="form-control"></textarea></div><div class="modal-footer"><button id="editorExecute" type="button" class="btn btn-primary">Evaluate</button><button id="editorDismiss" type="button" class="btn btn-default" data-dismiss="modal">Close</button></div></div></div></div></body></html>