<!DOCTYPE html
  PUBLIC "html">
<meta xmlns:doc="http://jaredkrinke.github.io/doc" name="viewport" content="width=device-width, initial-scale=1"><html xmlns:doc="http://jaredkrinke.github.io/doc" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>(learn 'scheme) - Tree Recursion</title><script src="https://code.jquery.com/jquery-2.1.1.min.js"></script><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css"><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/codemirror.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/codemirror.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/mode/scheme/scheme.min.js"></script><script src="jsLisp.js"></script><script src="editor.js"></script><link rel="stylesheet" href="editor.css"></head><body><div class="container"><nav class="navbar navbar-default"><div class="navbar-header"><button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#top-bar"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="index.html">(learn 'scheme)</a></div><div class="collapse navbar-collapse" id="top-bar"><ul class="nav navbar-nav"><li><a href="1-2-1-linearrecursio.html">&laquo; Previous</a></li><li class=""><a href="toc.html">Contents</a></li><li><a href="1-2-3-ordersofgrowth.html">Next &raquo;</a></li></ul><form class="navbar-form navbar-right"><button id="launchEditor" type="button" class="btn btn-default">Launch Editor</button></form></div></nav><h1>Tree Recursion</h1>
<p>Another common pattern of computation is called <strong>tree recursion</strong>. As an example, consider computing the sequence of Fibonacci numbers, in which each number is the sum of the preceding two:</p>

<div class=".pull-left"><img src="ch1-Z-G-11.gif"></div>
<p>In general, the Fibonacci numbers can be defined by the rule </p>

<div class=".pull-left"><img src="ch1-Z-G-12.gif"></div>
<p>We can immediately translate this definition into a recursive procedure for computing Fibonacci numbers:</p>
<pre>(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))</pre>

<div class=".pull-left"><p><img src="ch1-Z-G-13.gif"><br><small><u>Figure 1.5</u>:
                The tree-recursive process generated in computing <code>(fib 5)</code>.</small></p></div>
<p>Consider the pattern of this computation.  To compute <code>(fib 5)</code>, we compute <code>(fib 4)</code> and <code>(fib 3)</code>.  To compute <code>(fib 4)</code>, we compute <code>(fib 3)</code> and <code>(fib 2)</code>.  In general, the evolved process looks like a tree, as shown in figure 1.5. Notice that the branches split into two at each level (except at the bottom); this reflects the fact that the <code>fib</code> procedure calls itself twice each time it is invoked.</p>
<p>This procedure is instructive as a prototypical tree recursion, but it is a terrible way to compute Fibonacci numbers because it does so much redundant computation.  Notice in figure 1.5 that the entire computation of <code>(fib 3)</code> -- almost half the work -- is duplicated.  In fact, it is not hard to show that the number of times the procedure will compute <code>(fib 1)</code> or <code>(fib 0)</code> (the number of leaves in the above tree, in general) is precisely  <strong>F</strong><strong>i</strong><strong>b</strong>(<strong>n</strong> + 1).  To get an idea of how bad this is, one can show that the value of  <strong>F</strong><strong>i</strong><strong>b</strong>(<strong>n</strong>) grows exponentially with <strong>n</strong>.  More precisely (see exercise 1.13),  <strong>F</strong><strong>i</strong><strong>b</strong>(<strong>n</strong>) is the closest integer to <img src="book-Z-G-D-11.gif" border="0"><sup><strong>n</strong></sup> /<img src="book-Z-G-D-13.gif" border="0">5, where</p>

<div class=".pull-left"><img src="ch1-Z-G-14.gif"></div>
<p>is the <strong>golden ratio</strong>, which satisfies the equation</p>

<div class=".pull-left"><img src="ch1-Z-G-15.gif"></div>
<p>Thus, the process uses a number of steps that grows exponentially with the input.  On the other hand, the space required grows only linearly with the input, because we need keep track only of which nodes are above us in the tree at any point in the computation.  In general, the number of steps required by a tree-recursive process will be proportional to the number of nodes in the tree, while the space required will be proportional to the maximum depth of the tree.</p>
<p>We can also formulate an iterative process for computing the Fibonacci numbers.  The idea is to use a pair of integers <strong>a</strong> and <strong>b</strong>, initialized to  <strong>F</strong><strong>i</strong><strong>b</strong>(1) = 1 and  <strong>F</strong><strong>i</strong><strong>b</strong>(0) = 0, and to repeatedly apply the simultaneous transformations </p>

<div class=".pull-left"><img src="ch1-Z-G-16.gif"></div>
<p>It is not hard to show that, after applying this transformation <strong>n</strong> times, <strong>a</strong> and <strong>b</strong> will be equal, respectively, to  <strong>F</strong><strong>i</strong><strong>b</strong>(<strong>n</strong> + 1) and  <strong>F</strong><strong>i</strong><strong>b</strong>(<strong>n</strong>).  Thus, we can compute Fibonacci numbers iteratively using the procedure</p>
<pre>(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))</pre>
<p>This second method for computing  <strong>F</strong><strong>i</strong><strong>b</strong>(<strong>n</strong>) is a linear iteration.  The difference in number of steps required by the two methods -- one linear in <strong>n</strong>, one growing as fast as  <strong>F</strong><strong>i</strong><strong>b</strong>(<strong>n</strong>) itself -- is enormous, even for small inputs.</p>
<p>One should not conclude from this that tree-recursive processes are useless.  When we consider processes that operate on hierarchically structured data rather than numbers, we will find that tree recursion is a natural and powerful tool.<sup><a href="#footnote_31">31</a></sup> But even in numerical operations, tree-recursive processes can be useful in helping us to understand and design programs.  For instance, although the first <code>fib</code> procedure is much less efficient than the second one, it is more straightforward, being little more than a translation into Lisp of the definition of the Fibonacci sequence.  To formulate the iterative algorithm required noticing that the computation could be recast as an iteration with three state variables.</p>
<h2>Example: Counting change</h2><p>It takes only a bit of cleverness to come up with the iterative Fibonacci algorithm.  In contrast, consider the following problem: How many different ways can we make change of $ 1.00, given half-dollars, quarters, dimes, nickels, and pennies?  More generally, can we write a procedure to compute the number of ways to change any given amount of money?</p>
<p>This problem has a simple solution as a recursive procedure.  Suppose we think of the types of coins available as arranged in some order. Then the following relation holds:</p>
<p>The number of ways to change amount <strong>a</strong> using <strong>n</strong> kinds of coins equals</p>
<ul>
<li>the number of ways to change amount <strong>a</strong> using all but the first kind of coin, plus  </li>
<li>the number of ways to change amount <strong>a</strong> - <strong>d</strong> using all <strong>n</strong> kinds of coins, where <strong>d</strong> is the denomination of the first kind of coin. </li>
</ul>
<p>To see why this is true, observe that the ways to make change can be divided into two groups: those that do not use any of the first kind of coin, and those that do.  Therefore, the total number of ways to make change for some amount is equal to the number of ways to make change for the amount without using any of the first kind of coin, plus the number of ways to make change assuming that we do use the first kind of coin.  But the latter number is equal to the number of ways to make change for the amount that remains after using a coin of the first kind.</p>
<p>Thus, we can recursively reduce the problem of changing a given amount to the problem of changing smaller amounts using fewer kinds of coins. Consider this reduction rule carefully, and convince yourself that we can use it to describe an algorithm if we specify the following degenerate cases:<sup><a href="#footnote_32">32</a></sup></p>
<ul>
<li>If <strong>a</strong> is exactly 0, we should count that as 1 way to make change.  </li>
<li>If <strong>a</strong> is less than 0, we should count that as 0 ways to make change.  </li>
<li>If <strong>n</strong> is 0, we should count that as 0 ways to make change. </li>
</ul>
<p>We can easily translate this description into a recursive procedure:</p>
<pre>(define (count-change amount)
  (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (&lt; amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))</pre>
<p>(The <code>first-denomination</code> procedure takes as input the number of kinds of coins available and returns the denomination of the first kind.  Here we are thinking of the coins as arranged in order from largest to smallest, but any order would do as well.)  We can now answer our original question about changing a dollar:</p>
<div class="hidden hidden-code">(define (count-change amount)
  (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (&lt; amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))</div><pre>(count-change 100)</pre>
<blockquote>292</blockquote>
<p><code>Count-change</code> generates a tree-recursive process with redundancies similar to those in our first implementation of <code>fib</code>.  (It will take quite a while for that 292 to be computed.)  On the other hand, it is not obvious how to design a better algorithm for computing the result, and we leave this problem as a challenge. The observation that a tree-recursive process may be highly inefficient but often easy to specify and understand has led people to propose that one could get the best of both worlds by designing a "smart compiler" that could transform tree-recursive procedures into more efficient procedures that compute the same result.<sup><a href="#footnote_33">33</a></sup></p>


<u>Exercise 1.11</u><p>A function <strong>f</strong> is defined by the rule that <strong>f</strong>(<strong>n</strong>) = <strong>n</strong> if <strong>n</strong>&lt;3 and <strong>f</strong>(<strong>n</strong>) = <strong>f</strong>(<strong>n</strong> - 1) + 2<strong>f</strong>(<strong>n</strong> - 2) + 3<strong>f</strong>(<strong>n</strong> - 3) if <strong>n</strong><u>&gt;</u> 3.  Write a procedure that computes <strong>f</strong> by means of a recursive process.  Write a procedure that computes <strong>f</strong> by means of an iterative process. </p>


<u>Exercise 1.12</u><p>The following pattern of numbers is called <strong>Pascal's triangle</strong>.</p>

<div class=".pull-left"><img src="ch1-Z-G-17.gif"></div>
<p>The numbers at the edge of the triangle are all 1, and each number inside the triangle is the sum of the two numbers above it.<sup><a href="#footnote_34">34</a></sup> Write a procedure that computes elements of Pascal's triangle by means of a recursive process. </p>


<u>Exercise 1.13</u><p>Prove that  <strong>F</strong><strong>i</strong><strong>b</strong>(<strong>n</strong>) is the closest integer to <img src="book-Z-G-D-11.gif" border="0"><sup><strong>n</strong></sup>/<img src="book-Z-G-D-13.gif" border="0">5, where <img src="book-Z-G-D-11.gif" border="0"> =  (1 + <img src="book-Z-G-D-13.gif" border="0">5)/2.  Hint: Let <img src="book-Z-G-D-12.gif" border="0"> =  (1 - <img src="book-Z-G-D-13.gif" border="0">5)/2.  Use induction and the definition of the Fibonacci numbers (see section 1.2.2) to prove that  <strong>F</strong><strong>i</strong><strong>b</strong>(<strong>n</strong>) = (<img src="book-Z-G-D-11.gif" border="0"><sup><strong>n</strong></sup>  - <img src="book-Z-G-D-12.gif" border="0"><sup><strong>n</strong></sup>)/<img src="book-Z-G-D-13.gif" border="0">5.  </p>

<hr><small><p><sup><a name="footnote_31"></a>31</sup>An example of this was hinted at in section 1.1.3: The interpreter itself evaluates expressions using a tree-recursive process.   </p>
</small><small><p><sup><a name="footnote_32"></a>32</sup>For example, work through in detail how the reduction rule applies to the problem of making change for 10 cents using pennies and nickels.   </p>
</small><small><p><sup><a name="footnote_33"></a>33</sup>One approach to coping with redundant computations is to arrange matters so that we automatically construct a table of values as they are computed.  Each time we are asked to apply the procedure to some argument, we first look to see if the value is already stored in the table, in which case we avoid performing the redundant computation. This strategy, known as <strong>tabulation</strong> or <strong>memoization</strong>, can be implemented in a straightforward way.  Tabulation can sometimes be used to transform processes that require an exponential number of steps (such as <code>count-change</code>) into processes whose space and time requirements grow linearly with the input.  See exercise 3.27.   </p>
</small><small><p><sup><a name="footnote_34"></a>34</sup>The elements of Pascal's triangle are called the <strong>binomial coefficients</strong>, because the <strong>n</strong>th row consists of the coefficients of the terms in the expansion of (<strong>x</strong> + <strong>y</strong>)<sup><strong>n</strong></sup>.  This pattern for computing the coefficients appeared in Blaise Pascal's 1653 seminal work on probability theory, <strong>Traité du triangle arithmétique</strong>.  According to Knuth (1973), the same pattern appears in the <strong>Szu-yuen Yü-chien</strong> ("The Precious Mirror of the Four Elements"), published by the Chinese mathematician Chu Shih-chieh in 1303, in the works of the twelfth-century Persian poet and mathematician Omar Khayyam, and in the works of the twelfth-century Hindu mathematician Bháscara Áchárya.   </p>
</small><nav><ul class="pager"><li><a href="1-2-1-linearrecursio.html"><span>&laquo; Previous</span></a></li><li><a href="toc.html">Contents</a></li><li><a href="1-2-3-ordersofgrowth.html"><span>Next &raquo;</span></a></li></ul></nav><button id="tryItButton" class="hidden btn btn-info btn-xs pull-right">Try it</button></div><div id="editorModal" class="modal fade" tabindex="-1" role="dialog"><div class="modal-dialog modal-lg"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><h4 class="modal-title">Scheme Interpreter</h4></div><div class="modal-body"><label for="editorInput">Input</label><textarea id="editorInput" class="form-control"></textarea></div><div class="modal-body"><label for="editorOutput">Output</label><textarea id="editorOutput" class="form-control"></textarea></div><div class="modal-footer"><button id="editorExecute" type="button" class="btn btn-primary">Evaluate</button><button id="editorDismiss" type="button" class="btn btn-default" data-dismiss="modal">Close</button></div></div></div></div></body></html>