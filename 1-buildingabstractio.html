<!DOCTYPE html
  PUBLIC "html">
<meta xmlns:doc="http://jaredkrinke.github.io/doc" name="viewport" content="width=device-width, initial-scale=1">
<html xmlns:doc="http://jaredkrinke.github.io/doc" lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>(learn scheme) - Building Abstractions with Procedures</title><script src="http://code.jquery.com/jquery-2.1.1.min.js"></script><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css"><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
      <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/codemirror.min.css"><script src="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/codemirror.js"></script><script src="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/mode/scheme/scheme.min.js"></script><script src="jsLisp.js"></script><script src="editor.js"></script><link rel="stylesheet" href="editor.css">
   </head>
   <body>
      <div class="container">
         <nav class="navbar navbar-default">
            <div class="navbar-header"><button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#top-bar"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><span class="navbar-brand">(learn scheme)</span></div>
            <div class="collapse navbar-collapse" id="top-bar">
               <ul class="nav navbar-nav">
                  <li><a href="how-to-use-this-site.html">&laquo; Previous</a></li>
                  <li class=""><a href="toc.html">Contents</a></li>
                  <li><a href="1-1-theelementsofpro.html">Next &raquo;</a></li>
               </ul>
               <form class="navbar-form navbar-right"><button id="launchEditor" type="button" class="btn btn-default">Launch Editor</button></form>
            </div>
         </nav>
         <h1>Building Abstractions with Procedures</h1>
         
         <blockquote>  The acts of the mind, wherein it exerts its power over simple ideas, are chiefly
            these three: 1. Combining several simple ideas into one compound one, and thus all
            complex ideas are made.  2. The second is bringing two ideas, whether simple or complex,
            together, and setting them by one another so as to take a view of them at once, without
            uniting them into one, by which it gets all its ideas of relations. 3.  The third
            is separating them from all other ideas that accompany them in their real existence:
            this is called abstraction, and thus all its general ideas are made.
            <footer>John Locke, An Essay Concerning Human Understanding (1690)</footer>
         </blockquote>
         
         <p>We are about to study the idea of a <strong>computational process</strong>. Computational processes are abstract beings that inhabit computers. As they evolve,
            processes manipulate other abstract things called <strong>data</strong>.  The evolution of a process is directed by a pattern of rules called a <strong>program</strong>.  People create programs to direct processes. In effect, we conjure the spirits of
            the computer with our spells.
         </p>
         
         <p>A computational process is indeed much like a sorcerer's idea of a spirit.  It cannot
            be seen or touched.  It is not composed of matter at all.  However, it is very real.
            It can perform intellectual work. It can answer questions.  It can affect the world
            by disbursing money at a bank or by controlling a robot arm in a factory.  The programs
            we use to conjure processes are like a sorcerer's spells.  They are carefully composed
            from symbolic expressions in arcane and esoteric <strong>programming languages</strong> that prescribe the tasks we want our processes to perform.
         </p>
         
         <p>A computational process, in a correctly working computer, executes programs precisely
            and accurately.  Thus, like the sorcerer's apprentice, novice programmers must learn
            to understand and to anticipate the consequences of their conjuring.  Even small errors
            (usually called <strong>bugs</strong> or <strong>glitches</strong>) in programs can have complex and unanticipated consequences.
         </p>
         
         <p>Fortunately, learning to program is considerably less dangerous than learning sorcery,
            because the spirits we deal with are conveniently contained in a secure way.  Real-world
            programming, however, requires care, expertise, and wisdom.  A small bug in a computer-aided
            design program, for example, can lead to the catastrophic collapse of an airplane
            or a dam or the self-destruction of an industrial robot.
         </p>
         
         <p>Master software engineers have the ability to organize programs so that they can be
            reasonably sure that the resulting processes will perform the tasks intended.  They
            can visualize the behavior of their systems in advance.  They know how to structure
            programs so that unanticipated problems do not lead to catastrophic consequences,
            and when problems do arise, they can <strong>debug</strong> their programs.  Well-designed computational systems, like well-designed automobiles
            or nuclear reactors, are designed in a modular manner, so that the parts can be constructed,
            replaced, and debugged separately.
         </p>
         
         <h2>Programming in Lisp</h2>
         <p>We need an appropriate language for describing processes, and we will use for this
            purpose the programming language Lisp.  Just as our everyday thoughts are usually
            expressed in our natural language (such as English, French, or Japanese), and descriptions
            of quantitative phenomena are expressed with mathematical notations, our procedural
            thoughts will be expressed in Lisp.  Lisp was invented in the late 1950s as a formalism
            for reasoning about the use of certain kinds of logical expressions, called <strong>recursion equations</strong>, as a model for computation.  The language was conceived by John McCarthy and is
            based on his paper "Recursive Functions of Symbolic Expressions and Their Computation
            by Machine" (McCarthy 1960).
         </p>
         
         <p>Despite its inception as a mathematical formalism, Lisp is a practical programming
            language.  A Lisp <strong>interpreter</strong> is a machine that carries out processes described in the Lisp language.  The first
            Lisp interpreter was implemented by McCarthy with the help of colleagues and students
            in the Artificial Intelligence Group of the MIT Research Laboratory of Electronics
            and in the MIT Computation Center.<sup><a href="#footnote_1">1</a></sup> Lisp, whose name is an acronym for LISt Processing, was designed to provide symbol-manipulating
            capabilities for attacking programming problems such as the symbolic differentiation
            and integration of algebraic expressions.  It included for this purpose new data objects
            known as atoms and lists, which most strikingly set it apart from all other languages
            of the period.
         </p>
         
         <p>Lisp was not the product of a concerted design effort.  Instead, it evolved informally
            in an experimental manner in response to users' needs and to pragmatic implementation
            considerations.  Lisp's informal evolution has continued through the years, and the
            community of Lisp users has traditionally resisted attempts to promulgate any "official"
            definition of the language.  This evolution, together with the flexibility and elegance
            of the initial conception, has enabled Lisp, which is the second oldest language in
            widespread use today (only Fortran is older), to continually adapt to encompass the
            most modern ideas about program design.  Thus, Lisp is by now a family of dialects,
            which, while sharing most of the original features, may differ from one another in
            significant ways.  The dialect of Lisp used in this book is called Scheme.<sup><a href="#footnote_2">2</a></sup></p>
         
         <p>Because of its experimental character and its emphasis on symbol manipulation, Lisp
            was at first very inefficient for numerical computations, at least in comparison with
            Fortran.  Over the years, however, Lisp compilers have been developed that translate
            programs into machine code that can perform numerical computations reasonably efficiently.
            And for special applications, Lisp has been used with great effectiveness.<sup><a href="#footnote_3">3</a></sup>  Although Lisp has not yet overcome its old reputation as hopelessly inefficient,
            Lisp is now used in many applications where efficiency is not the central concern.
            For example, Lisp has become a language of choice for operating-system shell languages
            and for extension languages for editors and computer-aided design systems.
         </p>
         
         <p>If Lisp is not a mainstream language, why are we using it as the framework for our
            discussion of programming?  Because the language possesses unique features that make
            it an excellent medium for studying important programming constructs and data structures
            and for relating them to the linguistic features that support them.  The most significant
            of these features is the fact that Lisp descriptions of processes, called <strong>procedures</strong>, can themselves be represented and manipulated as Lisp data.  The importance of this
            is that there are powerful program-design techniques that rely on the ability to blur
            the traditional distinction between "passive" data and "active" processes.  As we
            shall discover, Lisp's flexibility in handling procedures as data makes it one of
            the most convenient languages in existence for exploring these techniques.  The ability
            to represent procedures as data also makes Lisp an excellent language for writing
            programs that must manipulate other programs as data, such as the interpreters and
            compilers that support computer languages.  Above and beyond these considerations,
            programming in Lisp is great fun.
         </p>
         
         
         
         
         <hr><small>
            <p><sup><a name="footnote_1"></a>1</sup>The <strong>Lisp 1 Programmer's Manual</strong> appeared in 1960, and the <strong>Lisp 1.5 Programmer's Manual</strong> (McCarthy 1965) was published in 1962.  The early history of Lisp is described in
               McCarthy 1978.   
            </p>
            </small><small>
            <p><sup><a name="footnote_2"></a>2</sup>The two dialects in which most major Lisp programs of the 1970s were written are MacLisp
               (Moon 1978; Pitman 1983), developed at the MIT Project MAC, and Interlisp (Teitelman
               1974), developed at Bolt Beranek and Newman Inc. and the Xerox Palo Alto Research
               Center.  Portable Standard Lisp (Hearn 1969; Griss 1981) was a Lisp dialect designed
               to be easily portable between different machines.  MacLisp spawned a number of subdialects,
               such as Franz Lisp, which was developed at the University of California at Berkeley,
               and Zetalisp (Moon 1981), which was based on a special-purpose processor designed
               at the MIT Artificial Intelligence Laboratory to run Lisp very efficiently.  The Lisp
               dialect used in this book, called Scheme (Steele 1975), was invented in 1975 by Guy
               Lewis Steele Jr. and Gerald Jay Sussman of the MIT Artificial Intelligence Laboratory
               and later reimplemented for instructional use at MIT.  Scheme became an IEEE standard
               in 1990 (IEEE 1990).  The Common Lisp dialect (Steele 1982, Steele 1990) was developed
               by the Lisp community to combine features from the earlier Lisp dialects to make an
               industrial standard for Lisp.  Common Lisp became an ANSI standard in 1994 (ANSI 1994).
               
            </p>
            </small><small>
            <p><sup><a name="footnote_3"></a>3</sup>One such special application was a breakthrough computation of scientific importance
               -- an integration of the motion of the Solar System that extended previous results
               by nearly two orders of magnitude, and demonstrated that the dynamics of the Solar
               System is chaotic.  This computation was made possible by new integration algorithms,
               a special-purpose compiler, and a special-purpose computer all implemented with the
               aid of software tools written in Lisp (Abelson et al. 1992; Sussman and Wisdom 1992).
               
            </p>
            </small><nav>
            <ul class="pager">
               <li><a href="how-to-use-this-site.html"><span>&laquo; Previous</span></a></li>
               <li><a href="toc.html">Contents</a></li>
               <li><a href="1-1-theelementsofpro.html"><span>Next &raquo;</span></a></li>
            </ul>
         </nav><button id="tryItButton" class="hidden btn btn-info btn-xs pull-right">Try it</button></div>
      <div id="editorModal" class="modal fade" tabindex="-1" role="dialog">
         <div class="modal-dialog modal-lg">
            <div class="modal-content">
               <div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><h4 class="modal-title">Scheme Interpreter</h4>
               </div>
               <div class="modal-body"><label for="editorInput">Input</label><textarea id="editorInput" class="form-control"></textarea></div>
               <div class="modal-body"><label for="editorOutput">Output</label><textarea id="editorOutput" class="form-control"></textarea></div>
               <div class="modal-footer"><button id="editorExecute" type="button" class="btn btn-primary">Evaluate</button><button id="editorDismiss" type="button" class="btn btn-default" data-dismiss="modal">Close</button></div>
            </div>
         </div>
      </div>
   </body>
</html>